#!/bin/bash
# File: auto-detect-sync.sh - Complete Automatic Change Detection and Sync Tool

# Configuration
GITHUB_REPO="https://github.com/rijwanmirza/ri.git"
GITHUB_TOKEN="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" 
APP_DIR="/var/www/UrlCampaignTracker"
DB_USER="neondb_owner"
DB_NAME="neondb"
SYNC_CONFIG="/root/sync_config.json"

# Create auto-detection system
mkdir -p /root/sync-system

# Create the main controller script
cat > /root/sync-system/controller.sh << 'EOF'
#!/bin/bash
# Main controller for auto-sync system

# Load configuration
source /root/sync-system/config.sh

# Log function
log() {
  echo "[$(date +"%Y-%m-%d %H:%M:%S")] $1" >> $LOG_FILE
  echo "$1"
}

# Clone latest from GitHub
clone_latest() {
  log "Cloning latest from GitHub..."
  rm -rf $TEMP_DIR
  mkdir -p $TEMP_DIR
  git clone ${GITHUB_REPO/https:\/\//https:\/\/$GITHUB_TOKEN@} $TEMP_DIR
  if [ $? -ne 0 ]; then
    log "Failed to clone from GitHub."
    return 1
  fi
  return 0
}

# Detect code changes
detect_code_changes() {
  log "Detecting code changes..."
  
  # Get list of changed files
  cd $APP_DIR
  CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "none")
  cd $TEMP_DIR
  NEW_COMMIT=$(git rev-parse HEAD)
  
  log "Current commit: $CURRENT_COMMIT"
  log "New commit: $NEW_COMMIT"
  
  if [ "$CURRENT_COMMIT" == "$NEW_COMMIT" ]; then
    log "No code changes detected."
    return 1
  else
    log "Code changes detected!"
    return 0
  fi
}

# Detect database schema changes
detect_schema_changes() {
  log "Detecting database schema changes..."
  
  # Extract schema from code files
  cd $TEMP_DIR
  grep -r "CREATE TABLE" --include="*.ts" --include="*.js" . > $TEMP_DIR/schema_new.txt
  grep -r "ALTER TABLE" --include="*.ts" --include="*.js" . >> $TEMP_DIR/schema_new.txt
  grep -r "ADD COLUMN" --include="*.ts" --include="*.js" . >> $TEMP_DIR/schema_new.txt
  
  cd $APP_DIR
  grep -r "CREATE TABLE" --include="*.ts" --include="*.js" . > $TEMP_DIR/schema_current.txt
  grep -r "ALTER TABLE" --include="*.ts" --include="*.js" . >> $TEMP_DIR/schema_current.txt
  grep -r "ADD COLUMN" --include="*.ts" --include="*.js" . >> $TEMP_DIR/schema_current.txt
  
  # Compare schemas
  diff $TEMP_DIR/schema_current.txt $TEMP_DIR/schema_new.txt > $TEMP_DIR/schema_diff.txt
  
  if [ -s $TEMP_DIR/schema_diff.txt ]; then
    log "Database schema changes detected!"
    return 0
  else
    log "No database schema changes detected."
    return 1
  fi
}

# Update application code
update_app_code() {
  log "Updating application code..."
  
  # Backup current application
  BACKUP_DIR="/tmp/app_backup_$(date +%Y%m%d_%H%M%S)"
  mkdir -p $BACKUP_DIR
  cp -R $APP_DIR/* $BACKUP_DIR/ 2>/dev/null || true
  cp -R $APP_DIR/.[^.]* $BACKUP_DIR/ 2>/dev/null || true
  log "Backup created at $BACKUP_DIR"
  
  # Preserve important files
  log "Preserving important environment files..."
  mkdir -p $TEMP_DIR/preserved
  for file in "${PRESERVED_FILES[@]}"; do
    if [ -f "$APP_DIR/$file" ]; then
      cp "$APP_DIR/$file" "$TEMP_DIR/preserved/"
    fi
  done
  
  # Update application directory
  log "Replacing application files..."
  rm -rf $APP_DIR
  mkdir -p $APP_DIR
  cp -R $TEMP_DIR/* $APP_DIR/ 2>/dev/null || true
  cp -R $TEMP_DIR/.[^.]* $APP_DIR/ 2>/dev/null || true
  
  # Restore preserved files
  log "Restoring preserved environment files..."
  for file in "${PRESERVED_FILES[@]}"; do
    if [ -f "$TEMP_DIR/preserved/$file" ]; then
      cp "$TEMP_DIR/preserved/$file" "$APP_DIR/$file"
    fi
  done
  
  # Install dependencies
  log "Installing dependencies..."
  cd $APP_DIR
  npm install
  
  # Fix permissions and create required directories
  log "Setting up directories and permissions..."
  for dir in "${REQUIRED_DIRS[@]}"; do
    mkdir -p "$APP_DIR/$dir"
    chmod 777 "$APP_DIR/$dir"
  done
  
  return 0
}

# Update database schema
update_database_schema() {
  log "Updating database schema..."
  
  # Execute comprehensive schema update
  $SYNC_SYSTEM_DIR/update_schema.sh
  
  return $?
}

# Restart application
restart_application() {
  log "Restarting application..."
  
  # Check if the forever script exists, if not create it
  if [ ! -f "$APP_DIR/forever.sh" ]; then
    log "Creating forever script..."
    $SYNC_SYSTEM_DIR/create_runtime_scripts.sh
  fi
  
  # Stop any existing processes
  pkill -f "forever.sh" || true
  pkill -f "tsx server/index.ts" || true
  fuser -k 5000/tcp >/dev/null 2>&1 || true
  sleep 2
  
  # Start application in background
  cd $APP_DIR
  log "Starting application in background mode..."
  nohup ./forever.sh >/dev/null 2>&1 &
  
  # Check if application started successfully
  sleep 5
  if pgrep -f "tsx server/index.ts" > /dev/null; then
    log "Application started successfully!"
    return 0
  else
    log "Failed to start application. Check logs."
    return 1
  fi
}

# Main function
main() {
  log "Starting auto-detection and sync process..."
  
  # Create sync directory if it doesn't exist
  mkdir -p $TEMP_DIR
  
  # Clone latest from GitHub
  clone_latest
  if [ $? -ne 0 ]; then
    log "Failed to clone from GitHub. Aborting."
    return 1
  fi
  
  # Detect changes
  CODE_CHANGED=false
  SCHEMA_CHANGED=false
  
  detect_code_changes
  if [ $? -eq 0 ]; then
    CODE_CHANGED=true
  fi
  
  detect_schema_changes
  if [ $? -eq 0 ]; then
    SCHEMA_CHANGED=true
  fi
  
  # If no changes detected, exit
  if [ "$CODE_CHANGED" == "false" ] && [ "$SCHEMA_CHANGED" == "false" ]; then
    log "No changes detected. Everything is up to date."
    return 0
  fi
  
  # Update application code if changed
  if [ "$CODE_CHANGED" == "true" ]; then
    log "Updating application code due to detected changes..."
    update_app_code
  fi
  
  # Always update schema (this is safer as it uses IF NOT EXISTS)
  log "Updating database schema..."
  update_database_schema
  
  # Restart application
  restart_application
  
  log "Auto-sync process completed successfully!"
  return 0
}

# Run main function
main
exit $?
EOF

# Create configuration script
cat > /root/sync-system/config.sh << EOF
#!/bin/bash
# Configuration for auto-sync system

# Repository settings
GITHUB_REPO="$GITHUB_REPO"
GITHUB_TOKEN="$GITHUB_TOKEN"

# Application settings
APP_DIR="$APP_DIR"
DB_USER="$DB_USER"
DB_NAME="$DB_NAME"

# System settings
SYNC_SYSTEM_DIR="/root/sync-system"
TEMP_DIR="/tmp/sync_temp"
LOG_FILE="/var/log/app_sync.log"

# Files to preserve during sync
PRESERVED_FILES=(
  "start.sh"
  "start-production.sh"
  ".env"
  "config.json"
  "ecosystem.config.js"
  ".env.local"
  ".env.production"
)

# Required directories
REQUIRED_DIRS=(
  "url_budget_logs"
  "Active_Url_Budget_Logs"
  "logs"
  "migrations"
)
EOF

# Create schema update script
cat > /root/sync-system/update_schema.sh << EOF
#!/bin/bash
# Schema update script

source /root/sync-system/config.sh

# Create comprehensive schema file
cat > \$TEMP_DIR/complete_schema.sql << 'SQLEOF'
-- Comprehensive schema that covers all possible tables and columns

-- Users table
CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255) NOT NULL,
  email VARCHAR(255),
  role VARCHAR(50),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_login TIMESTAMP WITH TIME ZONE
);

-- Sessions table
CREATE TABLE IF NOT EXISTS sessions (
  sid VARCHAR(255) PRIMARY KEY,
  sess JSON NOT NULL,
  expire TIMESTAMP WITH TIME ZONE NOT NULL
);

-- URLs table with ALL possible columns
CREATE TABLE IF NOT EXISTS urls (
  id SERIAL PRIMARY KEY,
  campaign_id INTEGER,
  name VARCHAR(255),
  target_url TEXT NOT NULL,
  clicks INTEGER DEFAULT 0,
  max_clicks INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status VARCHAR(50) DEFAULT 'active',
  price DECIMAL(10,2) DEFAULT 0,
  pending_budget_update BOOLEAN DEFAULT FALSE,
  budget_calculated TIMESTAMP WITH TIME ZONE,
  last_update_attempt TIMESTAMP WITH TIME ZONE,
  update_attempts INTEGER DEFAULT 0,
  max_daily_budget DECIMAL(10,2),
  spent_budget DECIMAL(10,2) DEFAULT 0,
  traffic_source VARCHAR(100),
  group_id INTEGER,
  last_click TIMESTAMP WITH TIME ZONE,
  notes TEXT,
  priority INTEGER DEFAULT 0
);

-- Campaigns table with ALL possible columns
CREATE TABLE IF NOT EXISTS campaigns (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status VARCHAR(20) DEFAULT 'active',
  api_key TEXT,
  provider VARCHAR(50),
  daily_budget DECIMAL(10,2),
  last_budget_update TIMESTAMP WITH TIME ZONE,
  owner_id INTEGER,
  traffic_source VARCHAR(100),
  total_budget DECIMAL(10,2),
  start_date TIMESTAMP WITH TIME ZONE,
  end_date TIMESTAMP WITH TIME ZONE
);

-- Redirects table
CREATE TABLE IF NOT EXISTS redirects (
  id SERIAL PRIMARY KEY,
  url_id INTEGER NOT NULL,
  redirect_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  ip_address VARCHAR(50),
  user_agent TEXT,
  referrer TEXT,
  country VARCHAR(50),
  browser VARCHAR(50),
  device VARCHAR(50)
);

-- Blacklisted URLs table with name column
CREATE TABLE IF NOT EXISTS blacklisted_urls (
  id SERIAL PRIMARY KEY,
  url TEXT NOT NULL,
  reason TEXT,
  name VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE,
  blacklisted_by INTEGER
);

-- Blacklisted patterns table
CREATE TABLE IF NOT EXISTS blacklisted_patterns (
  id SERIAL PRIMARY KEY,
  pattern TEXT NOT NULL,
  reason TEXT,
  name VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE,
  blacklisted_by INTEGER
);

-- API keys table
CREATE TABLE IF NOT EXISTS api_keys (
  id SERIAL PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  name VARCHAR(255),
  permissions JSON,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  user_id INTEGER,
  last_used TIMESTAMP WITH TIME ZONE
);

-- URL groups table
CREATE TABLE IF NOT EXISTS url_groups (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE,
  owner_id INTEGER
);

-- Settings table
CREATE TABLE IF NOT EXISTS settings (
  id SERIAL PRIMARY KEY,
  key VARCHAR(255) UNIQUE NOT NULL,
  value TEXT,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  description TEXT
);

-- Statistics table
CREATE TABLE IF NOT EXISTS statistics (
  id SERIAL PRIMARY KEY,
  date DATE NOT NULL,
  url_id INTEGER,
  campaign_id INTEGER,
  clicks INTEGER DEFAULT 0,
  unique_clicks INTEGER DEFAULT 0,
  cost DECIMAL(10,2) DEFAULT 0,
  conversions INTEGER DEFAULT 0
);

-- Auto-add any missing columns to all tables
DO \$\$
BEGIN
  -- Add all possible missing columns to urls table
  BEGIN
    ALTER TABLE urls ADD COLUMN IF NOT EXISTS traffic_source VARCHAR(100);
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE urls ADD COLUMN IF NOT EXISTS group_id INTEGER;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE urls ADD COLUMN IF NOT EXISTS last_click TIMESTAMP WITH TIME ZONE;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE urls ADD COLUMN IF NOT EXISTS notes TEXT;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE urls ADD COLUMN IF NOT EXISTS priority INTEGER DEFAULT 0;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  -- Add all possible missing columns to campaigns table
  BEGIN
    ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS owner_id INTEGER;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS traffic_source VARCHAR(100);
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS total_budget DECIMAL(10,2);
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS start_date TIMESTAMP WITH TIME ZONE;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS end_date TIMESTAMP WITH TIME ZONE;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  -- Add all possible missing columns to blacklisted_urls table
  BEGIN
    ALTER TABLE blacklisted_urls ADD COLUMN IF NOT EXISTS name VARCHAR(255);
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE blacklisted_urls ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE blacklisted_urls ADD COLUMN IF NOT EXISTS blacklisted_by INTEGER;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  -- Add all possible missing columns to blacklisted_patterns table
  BEGIN
    ALTER TABLE blacklisted_patterns ADD COLUMN IF NOT EXISTS name VARCHAR(255);
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE blacklisted_patterns ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
  
  BEGIN
    ALTER TABLE blacklisted_patterns ADD COLUMN IF NOT EXISTS blacklisted_by INTEGER;
  EXCEPTION WHEN OTHERS THEN
    -- Column already exists or other error, continue
  END;
END \$\$;

-- Setup all triggers
DROP TRIGGER IF EXISTS enforce_blacklist_insert_trigger ON urls;
DROP TRIGGER IF EXISTS enforce_blacklist_update_trigger ON urls;
DROP TRIGGER IF EXISTS update_updated_at_urls_trigger ON urls;
DROP TRIGGER IF EXISTS update_updated_at_campaigns_trigger ON campaigns;

-- Drop existing functions if they exist
DROP FUNCTION IF EXISTS enforce_blacklist();
DROP FUNCTION IF EXISTS update_updated_at_column();

-- Create function to enforce blacklist
CREATE OR REPLACE FUNCTION enforce_blacklist() RETURNS TRIGGER AS \$\$
BEGIN
    -- Check if the new URL matches any blacklisted pattern
    IF EXISTS (
        SELECT 1 FROM blacklisted_patterns 
        WHERE NEW.target_url IS NOT NULL AND NEW.target_url ~ pattern
    ) THEN
        RAISE EXCEPTION 'URL matches a blacklisted pattern';
    END IF;
    RETURN NEW;
END;
\$\$ LANGUAGE plpgsql;

-- Create function to update updated_at column
CREATE OR REPLACE FUNCTION update_updated_at_column() RETURNS TRIGGER AS \$\$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
\$\$ LANGUAGE plpgsql;

-- Create triggers to enforce blacklist on insert and update
CREATE TRIGGER enforce_blacklist_insert_trigger
BEFORE INSERT ON urls
FOR EACH ROW
EXECUTE FUNCTION enforce_blacklist();

CREATE TRIGGER enforce_blacklist_update_trigger
BEFORE UPDATE ON urls
FOR EACH ROW
EXECUTE FUNCTION enforce_blacklist();

-- Create triggers to update updated_at column
CREATE TRIGGER update_updated_at_urls_trigger
BEFORE UPDATE ON urls
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_updated_at_campaigns_trigger
BEFORE UPDATE ON campaigns
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_urls_campaign_id ON urls(campaign_id);
CREATE INDEX IF NOT EXISTS idx_urls_status ON urls(status);
CREATE INDEX IF NOT EXISTS idx_redirects_url_id ON redirects(url_id);
CREATE INDEX IF NOT EXISTS idx_redirects_redirect_time ON redirects(redirect_time);
CREATE INDEX IF NOT EXISTS idx_sessions_expire ON sessions(expire);
SQLEOF

# Apply comprehensive schema
echo "Applying comprehensive database schema..."
psql -U \$DB_USER -d \$DB_NAME -f \$TEMP_DIR/complete_schema.sql
EOF

# Create runtime scripts generator
cat > /root/sync-system/create_runtime_scripts.sh << 'EOF'
#!/bin/bash
# Create runtime scripts

source /root/sync-system/config.sh

# Create the forever script that keeps the app running
cat > "$APP_DIR/forever.sh" << 'EOFSH'
#!/bin/bash
# This script ensures the application runs forever and survives terminal disconnects

# Go to application directory
cd $(dirname $0)
mkdir -p logs

# Kill any existing processes on the port
fuser -k 5000/tcp >/dev/null 2>&1 || true
sleep 2

# Make sure start script is executable
chmod +x ./start.sh

# Start the application in a continuous loop
echo "[$(date)] Starting application in forever mode..." >> logs/forever.log
while true; do
  echo "[$(date)] Starting application..." >> logs/forever.log
  ./start.sh >> logs/app.log 2>&1
  echo "[$(date)] Application exited with code $?, restarting in 5 seconds..." >> logs/forever.log
  sleep 5
done
EOFSH
chmod +x "$APP_DIR/forever.sh"

# Create status checker script
cat > "$APP_DIR/status.sh" << 'EOFSH'
#!/bin/bash
# Check application status
cd $(dirname $0)

echo "======== Application Status ========"
if pgrep -f "forever.sh" > /dev/null; then
  echo "âœ… Forever process: RUNNING"
else
  echo "âŒ Forever process: NOT RUNNING"
fi

if pgrep -f "tsx server/index.ts" > /dev/null; then
  echo "âœ… Application process: RUNNING"
else
  echo "âŒ Application process: NOT RUNNING"
fi

# Check port 5000
if netstat -tuln | grep -q ":5000 "; then
  echo "âœ… Port 5000: OPEN (application is accessible)"
else
  echo "âŒ Port 5000: CLOSED (application may still be starting)"
fi

# Check database
echo -n "ðŸ“Š Database connection: "
if psql -U $(grep DB_USER= start.sh | cut -d= -f2) -d $(grep DB_NAME= start.sh | cut -d= -f2) -c "SELECT 1" > /dev/null 2>&1; then
  echo "CONNECTED"
else
  echo "DISCONNECTED"
fi

# Show last 5 log entries
echo -e "\nðŸ“ Last 5 log entries:"
tail -n 5 logs/app.log

echo "===================================="
echo "Use ./restart.sh to restart the application"
echo "Use tail -f logs/app.log to view live logs"
EOFSH
chmod +x "$APP_DIR/status.sh"

# Create restart script
cat > "$APP_DIR/restart.sh" << 'EOFSH'
#!/bin/bash
# Restart application
cd $(dirname $0)

echo "Restarting application..."
pkill -f "forever.sh"
pkill -f "tsx server/index.ts"
sleep 2
nohup ./forever.sh >/dev/null 2>&1 &
echo "Application restarted in background mode"
echo "Run ./status.sh to check status"
EOFSH
chmod +x "$APP_DIR/restart.sh"
EOF

# Create auto-sync script
cat > /root/sync-system/auto-sync.sh << 'EOF'
#!/bin/bash
# Auto-sync script - run this to detect and apply changes

source /root/sync-system/config.sh

echo "Starting auto-sync process..."
$SYNC_SYSTEM_DIR/controller.sh

if [ $? -eq 0 ]; then
  echo "Auto-sync completed successfully!"
else
  echo "Auto-sync encountered errors. Check the log at $LOG_FILE"
fi
EOF

# Create cron setup script
cat > /root/sync-system/setup-cron.sh << 'EOF'
#!/bin/bash
# Setup cron job for periodic auto-sync

source /root/sync-system/config.sh

# Create temporary crontab file
TEMP_CRONTAB=$(mktemp)

# Get current crontab
crontab -l > $TEMP_CRONTAB 2>/dev/null || echo "" > $TEMP_CRONTAB

# Check if auto-sync entry already exists
if grep -q "auto-sync.sh" $TEMP_CRONTAB; then
  echo "Cron job for auto-sync already exists."
else
  # Add auto-sync job to run every hour
  echo "# Auto-sync job - runs every hour to detect and apply changes" >> $TEMP_CRONTAB
  echo "0 * * * * $SYNC_SYSTEM_DIR/auto-sync.sh >> $LOG_FILE 2>&1" >> $TEMP_CRONTAB
  
  # Install new crontab
  crontab $TEMP_CRONTAB
  echo "Cron job installed. Auto-sync will run every hour."
fi

# Clean up
rm $TEMP_CRONTAB
EOF

# Create initial app backup
mkdir -p /root/app-backups
cp -R $APP_DIR /root/app-backups/original_app_$(date +%Y%m%d_%H%M%S)

# Set permissions for all scripts
chmod +x /root/sync-system/*.sh

# Create main user interface script
cat > /root/auto-sync-manager.sh << 'EOF'
#!/bin/bash
# Auto-Sync Manager - Main interface for managing auto-sync system

# Load configuration
source /root/sync-system/config.sh

# Display help message
show_help() {
  echo "Auto-Sync Manager - Keep VPS in sync with Replit automatically"
  echo ""
  echo "Usage: $0 [command]"
  echo ""
  echo "Commands:"
  echo "  sync          Run the auto-sync process now (detect and apply changes)"
  echo "  status        Check status of the application"
  echo "  enable-cron   Setup cron job to run auto-sync hourly"
  echo "  disable-cron  Remove cron job for auto-sync"
  echo "  logs          View auto-sync logs"
  echo "  app-logs      View application logs"
  echo "  restart       Restart the application"
  echo "  help          Show this help message"
  echo ""
}

# Check the application status
check_status() {
  if [ -f "$APP_DIR/status.sh" ]; then
    $APP_DIR/status.sh
  else
    echo "Status script not found. Run sync first to create it."
  fi
}

# Disable cron job
disable_cron() {
  TEMP_CRONTAB=$(mktemp)
  crontab -l > $TEMP_CRONTAB 2>/dev/null || echo "" > $TEMP_CRONTAB
  
  # Remove auto-sync entries
  sed -i '/auto-sync\.sh/d' $TEMP_CRONTAB
  
  # Install new crontab
  crontab $TEMP_CRONTAB
  rm $TEMP_CRONTAB
  
  echo "Auto-sync cron job has been disabled."
}

# View logs
view_logs() {
  if [ -f "$LOG_FILE" ]; then
    tail -n 50 $LOG_FILE
  else
    echo "No auto-sync logs found."
  fi
}

# View application logs
view_app_logs() {
  if [ -f "$APP_DIR/logs/app.log" ]; then
    tail -n 50 $APP_DIR/logs/app.log
  else
    echo "No application logs found."
  fi
}

# Main command processor
if [ $# -eq 0 ]; then
  show_help
  exit 0
fi

case "$1" in
  sync)
    $SYNC_SYSTEM_DIR/auto-sync.sh
    ;;
  status)
    check_status
    ;;
  enable-cron)
    $SYNC_SYSTEM_DIR/setup-cron.sh
    ;;
  disable-cron)
    disable_cron
    ;;
  logs)
    view_logs
    ;;
  app-logs)
    view_app_logs
    ;;
  restart)
    if [ -f "$APP_DIR/restart.sh" ]; then
      $APP_DIR/restart.sh
    else
      echo "Restart script not found. Run sync first to create it."
    fi
    ;;
  help|--help|-h)
    show_help
    ;;
  *)
    echo "Unknown command: $1"
    show_help
    exit 1
    ;;
esac
EOF

# Make the manager executable
chmod +x /root/auto-sync-manager.sh

# Initial setup - run controller once
echo "Setting up initial auto-sync system..."
/root/sync-system/controller.sh

echo ""
echo "==================================================================="
echo "   AUTOMATIC CHANGE DETECTION AND SYNC SYSTEM INSTALLED"
echo "==================================================================="
echo ""
echo "This system will automatically detect ANY changes between your"
echo "Replit and VPS versions, including:"
echo ""
echo "  - Code changes from GitHub"
echo "  - Database schema changes and missing columns"
echo "  - Environment configuration"
echo ""
echo "TO USE THIS SYSTEM:"
echo ""
echo "  1. Run automatic sync:   /root/auto-sync-manager.sh sync"
echo "  2. Check app status:     /root/auto-sync-manager.sh status"
echo "  3. View app logs:        /root/auto-sync-manager.sh app-logs"
echo "  4. Enable hourly sync:   /root/auto-sync-manager.sh enable-cron"
echo ""
echo "Your application is now running in 24/7 mode and will survive"
echo "terminal disconnects."
echo ""
echo "==================================================================="